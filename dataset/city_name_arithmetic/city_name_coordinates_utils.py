# -*- coding: utf-8 -*-
"""

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CYfW2Tj35SZISCY8KigNB2YtwUgN1SJN
"""
import random
import json
import requests
from geopy.geocoders import Nominatim

def get_city_coordinates(city_list, save_to_json=False):
    # Create an instance of the Nominatim geocoder
    geolocator = Nominatim(user_agent="city_coords_fetcher")

    # Create a dictionary to store city coordinates
    city_coordinates = {}

    for city in city_list:
        try:
            # Fetch the location data for the city
            location = geolocator.geocode(city)
            if location:
                # Round the coordinates to the nearest integer and store in the dictionary
                city_coordinates[city] = (round(location.longitude), round(location.latitude))
            else:
                print(f"Could not fetch coordinates for {city}")
        except Exception as e:
            print(f"Error during geocoding for {city}: {e}")

    # If the save_to_json flag is True, save the data as a JSON file
    if save_to_json:
        with open("city_coordinates.json", "w") as outfile:
            json.dump(city_coordinates, outfile, indent = 2)

    return city_coordinates


def generate_equations(city_coords_file, N, m, flag=1):
    # Load city coordinates from the JSON file
    with open(city_coords_file, 'r') as f:
        city_coords = json.load(f)

    # All available cities from the coordinates
    all_cities = list(city_coords.keys())

    # Define operations
    operations = ['+', '-', '*']

    # Initialize lists to store questions in city names and numbers
    questions_city = []
    questions_num = []
    answers = []

    # Generate m-city equations
    for _ in range(N):
        # Randomly sample m cities from all cities with replacement
        equation_cities = random.choices(all_cities, k=m)
        
        # Initialize equation strings
        equation_city_str = equation_cities[0]
        if flag == 1:
            equation_num_str = str(city_coords[equation_cities[0]][0])
        else:
            equation_num_str = str(city_coords[equation_cities[0]][1])

        # Generate the equation
        for i in range(1, m):
            op = random.choice(operations)
            equation_city_str += " " + op + " " + equation_cities[i]
            
            if flag == 1:
                equation_num_str += " " + op + " " + str(city_coords[equation_cities[i]][0])
            else:
                equation_num_str += " " + op + " " + str(city_coords[equation_cities[i]][1])

        # Evaluate the equation
        answer = eval(equation_num_str)

        questions_city.append(equation_city_str)
        questions_num.append(equation_num_str)
        answers.append(answer)

    # Prepare the data for JSON file
    data_to_save = [{"question": q, "answer": a} for q, a in zip(questions_city, answers)]
    
    # Determine filename based on flag
    filename = "arithmetic_equations_longitude.json" if flag == 1 else "arithmetic_equations_latitude.json"
    
    # Save to JSON
    with open(filename, "w") as outfile:
        json.dump(data_to_save, outfile, indent=2)

    return questions_city, questions_num, answers

def verify_equations(equations_file, city_coords_file, flag=1):
    # Load the equations and city coordinates from the JSON files
    with open(equations_file, 'r') as f_eq:
        equations = json.load(f_eq)
    
    with open(city_coords_file, 'r') as f_coords:
        city_coords = json.load(f_coords)
    
    # Determine the type (latitude or longitude) based on the flag
    coord_type = "longitude" if flag == 1 else "latitude"
    
    # Initialize the results list
    verification_results = []
    all_correct = True  # Assume all equations are correct initially
    
    for equation in equations:
        city_eq = equation["question"]
        answer = equation["answer"]
        
        # Split the city equation to get individual elements
        parts = city_eq.split()
        
        # Reconstruct city names that might have been split
        reconstructed_parts = []
        temp_name = ""
        for part in parts:
            if part not in ['+', '-', '*']:
                temp_name += (part + " ")
            else:
                reconstructed_parts.append(temp_name.strip())
                reconstructed_parts.append(part)
                temp_name = ""
        if temp_name:
            reconstructed_parts.append(temp_name.strip())

        # Construct the numeric equation string and reason string
        numeric_eq = ""
        reason = ""
        for part in reconstructed_parts:
            if part not in ['+', '-', '*']:
                coord_value = city_coords[part][0] if flag == 1 else city_coords[part][1]
                numeric_eq += str(coord_value)
                reason += f'"{part}" = {coord_value}, '
            else:
                numeric_eq += part
        
        # Evaluate the numeric equation
        computed_answer = eval(numeric_eq)
        
        # Construct the final result
        correctness = "Correct" if computed_answer == answer else "Incorrect"
        if correctness == "Incorrect":
            all_correct = False  # Update the flag if any equation is incorrect
        
        verification_entry = {
            "city equation": f'"{city_eq}" = {answer}',
            "reason": reason.rstrip(", ") + f', then we have {numeric_eq} = {computed_answer}',
            "final result": correctness
        }
        verification_results.append(verification_entry)
    
    # Determine the filename for saving based on flag
    filename = "verify_arithmetic_equations_longitude.json" if flag == 1 else "verify_arithmetic_equations_latitude.json"
    
    # Save verification results to JSON
    with open(filename, "w") as outfile:
        json.dump(verification_results, outfile, indent=2)

    # Print if all equations are correct
    if all_correct:
        print("All equations are correct!")
    
    return verification_results

 


