# -*- coding: utf-8 -*-
"""

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CYfW2Tj35SZISCY8KigNB2YtwUgN1SJN
"""
import random
import json
import requests
from geopy.geocoders import Nominatim
import re


def get_city_coordinates(city_list, save_to_json=False):
    # Create an instance of the Nominatim geocoder
    geolocator = Nominatim(user_agent="city_coords_fetcher")

    # Create a dictionary to store city coordinates
    city_coordinates = {}

    for city in city_list:
        try:
            # Fetch the location data for the city
            location = geolocator.geocode(city)
            if location:
                # Round the coordinates to the nearest integer and store in the dictionary
                city_coordinates[city] = (round(location.longitude), round(location.latitude))
            else:
                print(f"Could not fetch coordinates for {city}")
        except Exception as e:
            print(f"Error during geocoding for {city}: {e}")

    # If the save_to_json flag is True, save the data as a JSON file
    if save_to_json:
        with open("city_coordinates.json", "w") as outfile:
            json.dump(city_coordinates, outfile, indent = 2)

    return city_coordinates


def generate_equations(city_coords_file, N, m, flag=1, file_name="arithmetic_equations_longitude.json"):
    # Load city coordinates from the JSON file
    with open(city_coords_file, 'r') as f:
        city_coords = json.load(f)

    # All available cities from the coordinates
    all_cities = list(city_coords.keys())

    # Define operations
    # operations = ['+', '-', '*']
    operations = ['+', '-']
    # Initialize lists to store questions in city names and numbers
    questions_city = []
    questions_num = []
    answers = []

    # Generate m-city equations
    for _ in range(N):
        # Randomly sample m cities from all cities with replacement
        equation_cities = random.choices(all_cities, k=m)
        
        # Initialize equation strings
        equation_city_str = equation_cities[0]
        if flag == 1:
            equation_num_str = str(city_coords[equation_cities[0]][0])
        else:
            equation_num_str = str(city_coords[equation_cities[0]][1])

        # Generate the equation
        for i in range(1, m):
            op = random.choice(operations)
            equation_city_str += " " + op + " " + equation_cities[i]
            
            if flag == 1:
                equation_num_str += " " + op + " " + str(city_coords[equation_cities[i]][0])
            else:
                equation_num_str += " " + op + " " + str(city_coords[equation_cities[i]][1])

        # Evaluate the equation
        answer = eval(equation_num_str)

        questions_city.append(equation_city_str)
        questions_num.append(equation_num_str)
        answers.append(answer)

    # Prepare the data for JSON file
    data_to_save = [{"question": q, "answer": a} for q, a in zip(questions_city, answers)]
    
    # Determine filename based on flag
    if(file_name):
        filename = file_name
    else:
        filename = "arithmetic_equations_longitude.json" if flag == 1 else "arithmetic_equations_latitude.json"
    
    # Save to JSON
    with open(filename, "w") as outfile:
        json.dump(data_to_save, outfile, indent=2)

    return questions_city, questions_num, answers

def verify_equations(equations_file, city_coords_file, flag=1, file_name="verify_arithmetic_equations_longitude.json"):
    # Load the equations and city coordinates from the JSON files
    with open(equations_file, 'r') as f_eq:
        equations = json.load(f_eq)
    
    with open(city_coords_file, 'r') as f_coords:
        city_coords = json.load(f_coords)
    
    # Determine the type (latitude or longitude) based on the flag
    coord_type = "longitude" if flag == 1 else "latitude"
    
    # Initialize the results list
    verification_results = []
    all_correct = True  # Assume all equations are correct initially
    
    for equation in equations:
        city_eq = equation["question"]
        answer = equation["answer"]
        
        # Split the city equation to get individual elements
        parts = city_eq.split()
        
        # Reconstruct city names that might have been split
        reconstructed_parts = []
        temp_name = ""
        for part in parts:
            if part not in ['+', '-', '*']:
                temp_name += (part + " ")
            else:
                reconstructed_parts.append(temp_name.strip())
                reconstructed_parts.append(part)
                temp_name = ""
        if temp_name:
            reconstructed_parts.append(temp_name.strip())

        # Construct the numeric equation string and reason string
        numeric_eq = ""
        reason = ""
        for part in reconstructed_parts:
            if part not in ['+', '-', '*']:
                coord_value = city_coords[part][0] if flag == 1 else city_coords[part][1]
                numeric_eq += str(coord_value)
                reason += f'"{part}" = {coord_value}, '
            else:
                numeric_eq += part
        
        # Evaluate the numeric equation
        computed_answer = eval(numeric_eq)
        
        # Construct the final result
        correctness = "Correct" if computed_answer == answer else "Incorrect"
        if correctness == "Incorrect":
            all_correct = False  # Update the flag if any equation is incorrect
        
        verification_entry = {
            "city equation": f'"{city_eq}" = {answer}',
            "reason": reason.rstrip(", ") + f', then we have {numeric_eq} = {computed_answer}',
            "final result": correctness
        }
        verification_results.append(verification_entry)
    
    # Determine the filename for saving based on flag
    if(file_name):
        filename = file_name
    else:
        filename = "verify_arithmetic_equations_longitude.json" if flag == 1 else "verify_arithmetic_equations_latitude.json"
    
    # Save verification results to JSON
    with open(filename, "w") as outfile:
        json.dump(verification_results, outfile, indent=2)

    # Print if all equations are correct
    if all_correct:
        print("All equations are correct!")
    
    return verification_results, all_correct

 


import json

def generate_prompts_from_json(input_file, output_file):
    # Load the data from the input JSON file
    with open(input_file, 'r') as f:
        data = json.load(f)
    
    # Lists to store the generated prompts
    x = []
    y = []
    z = []
    z_uninformative = []
    
    # Dictionary to store general uninformative facts about cities
    city_list = [
        "New York", "Los Angeles", "London", "Tokyo", "Beijing",
        "Sydney", "Cairo", "Sao Paulo", "Mumbai", "Moscow",
        "Lagos", "Johannesburg", "Buenos Aires", "Paris", "Istanbul",
        "Seoul", "Bangkok", "Rome", "Toronto", "Mexico City"
    ]

    city_facts = {
        "Buenos Aires": "Buenos Aires is the capital of Argentina. It is located in the southern hemisphere.",
        "Toronto": "Toronto is the largest city in Canada. It's known for its modern skyline and the iconic CN Tower.",
        "New York": "New York, often called New York City, is the most populous city in the United States. It's known for the Statue of Liberty.",
        "Mumbai": "Mumbai, formerly known as Bombay, is the financial capital of India. It's located on the west coast.",
        "Los Angeles": "Los Angeles is located in California, USA. It's famous for Hollywood and its entertainment industry.",
        "Moscow": "Moscow is the capital of Russia. The Kremlin and Red Square are among its most well-known landmarks.",
        "Istanbul": "Istanbul is a major city in Turkey. It's known for its rich history and the Hagia Sophia.",
        "Rome": "Rome is the capital of Italy. It has a rich history and is home to the Colosseum.",
        "Paris": "Paris is the capital of France. It's often referred to as 'The City of Love'.",
        "Beijing": "Beijing is the capital of China. It's known for its ancient sites including the Forbidden City.",
        "Tokyo": "Tokyo is the capital of Japan. It's a bustling metropolis known for its modern architecture.",
        "London": "London is the capital of England and the United Kingdom. It's renowned for its history, from its Roman beginnings to its cosmopolitan present.",
        "Sydney": "Sydney is the largest city in Australia. It's famous for its Harbour Bridge and the Sydney Opera House.",
        "Cairo": "Cairo is the capital of Egypt. It's located near the Nile Delta and is known for its ancient Egyptian history.",
        "Sao Paulo": "Sao Paulo is a sprawling city in Brazil. It's a major financial center and is known for its cultural institutions.",
        "Lagos": "Lagos is the largest city in Nigeria. It's a major financial center in Africa and is home to one of the largest and busiest ports on the continent.",
        "Johannesburg": "Johannesburg, often known as Jo'burg, is the largest city in South Africa. It's the economic heart of Africa and is known for its modern architecture.",
        "Seoul": "Seoul is the capital and largest metropolis of South Korea. It's a vibrant city known for its modern skyscrapers and ancient palaces.",
        "Bangkok": "Bangkok is the capital of Thailand. It's known for its ornate temples, bustling street markets, and the grand palace.",
        "Mexico City": "Mexico City is the capital of Mexico. It's known for its Templo Mayor, a 13th-century Aztec temple, and the Palacio Nacional, which houses historic murals."
    }

    
    for item in data:
        # Extract the city equation and reason from the data
        city_equation = item["city equation"].split("=")[0].strip()
        
        reason = item["reason"].split(", then")[0]
        
        # Generate the z prompts
        z_prompt = "Using the longitudes of cities, the equation {} translates as {}. Here the longitudes of the western hemisphere are negative numbers. And we round the coordinates to the nearest integer. This gives the result.".format(city_equation, reason)
        z.append(z_prompt)
        
        # Extract cities involved in the equation
        #cities_involved = [word.replace("\"", "").strip() for word in city_equation.split() if word.replace("\"", "").strip() in city_facts]
        city_pattern = r'\b(' + '|'.join(city_list) + r')\b'
        cities_involved = re.findall(city_pattern, city_equation)
        
        # Generate the uninformative z prompts
        z_uninfo_prompt = " ".join([city_facts[city] for city in cities_involved])
        
        z_uninformative.append(z_uninfo_prompt)
        
        # Append to x and y
        x.append(city_equation)
        y.append(item["city equation"].split("=")[1].strip())
        # print(city_equation)
        # print("\n")
        # print(cities_involved)
        # print("\n")
        # print(city_pattern)
    # Create the output data structure
    output_data = {
        "x": x,
        "y": y,
        "z": z,
        "z_uninformative": z_uninformative
    }
    
    # Save to the output JSON file
    with open(output_file, "w") as f:
        json.dump(output_data, f, indent=2)
        
    return output_data

